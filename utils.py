# -*- coding: utf-8 -*-

"""
/***************************************************************************
 CSVTools
                                 A QGIS plugin
 Adds new processing algorithms and models that deal with CSV files
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-02-19
        copyright            : (C) 2019 by Yann Voté
        email                : ygversil@lilo.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Yann Voté'
__date__ = '2019-02-19'
__copyright__ = '(C) 2019 by Yann Voté'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import csv
import io
import re
import sqlite3
import tempfile

from qgis.core import QgsDataSourceUri
import psycopg2


_DATETIME_REGEXP = re.compile(r'(?P<year>\d+)-(?P<month>\d+)-(?P<day>\d+)'
                              r'[T\s]+'
                              r'(?P<hour>\d+):(?P<minute>\d+):(?P<second>\d+)'
                              r'(?P<microseconds>.\d+)?Z?')


def dump_layer_to_csv(layer, fields, csvf):
    """Copy the layer into the given file-object using given fields."""
    select_stmt = ', '.join(fields)
    layer_type = layer.storageType()
    if 'GPKG' in layer_type or 'SQLite' in layer_type:
        dbpath, table = layer.dataProvider().dataSourceUri().split('|')
        _, table = table.split('=')
        rows = _sqlite_rows(dbpath, table, select_stmt)
    elif 'PostgreSQL' in layer_type:
        uri = QgsDataSourceUri(layer.dataProvider().dataSourceUri())
        table = '{schema}.{table}'.format(schema=uri.schema(),
                                          table=uri.table())
        rows = _postgresql_rows(uri.connectionInfo(), table, select_stmt)
    writer = csv.writer(csvf, delimiter='|', quotechar='"',
                        quoting=csv.QUOTE_MINIMAL)
    writer.writerow(fields)
    for row in rows:
        row = map(lambda v: str(v).strip() if v is not None else '', row)
        row = map(_normalize_boolean, row)
        row = map(_normalize_datetime, row)
        writer.writerow(row)


def _normalize_boolean(v):
    return {'t': '1', 'f': '0'}.get(v, v)


def _normalize_datetime(v):
    m = _DATETIME_REGEXP.match(v)
    if not m:
        return v
    else:
        return ('{year}-{month}-{day}'
                'T'
                '{hour}:{minute}:{second}'
                'Z'.format(**m.groupdict()))


def _postgresql_rows(connection_info, table, select_stmt):
    """Yield each row from the given PostgreSQL table as a tuple."""
    with tempfile.TemporaryFile() as fb, \
            io.TextIOWrapper(fb, encoding='utf-8', newline='') as f, \
            psycopg2.connect(connection_info) as conn, \
            conn.cursor() as cur:
        cur.copy_expert(
            'copy (select {select_stmt} from {table}) to stdout '
            'with (format csv, '
            "delimiter '|', "
            "null '', "
            "header false, "
            "quote '\"')".format(select_stmt=select_stmt,
                                 table=table),
            f
        )
        f.seek(0)
        reader = csv.reader(f, delimiter='|', quotechar='"')
        yield from reader


def _sqlite_rows(dbpath, table, select_stmt):
    """Yield each row from the given SQLite table as a tuple."""
    with sqlite3.connect(dbpath) as conn:
        cur = conn.cursor()
        cur.execute(
            'select {select_stmt} from {table}'.format(select_stmt=select_stmt,
                                                       table=table)
        )
        yield from cur
