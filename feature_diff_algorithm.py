# -*- coding: utf-8 -*-

"""
/***************************************************************************
 CSVTools
                                 A QGIS plugin
 Adds new processing algorithms and models that deal with CSV files
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-02-19
        copyright            : (C) 2019 by Yann Voté
        email                : ygversil@lilo.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Yann Voté'
__date__ = '2019-02-19'
__copyright__ = '(C) 2019 by Yann Voté'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from itertools import starmap
import difflib
import io
import os
import tempfile

from pygments import highlight
from pygments.formatters import HtmlFormatter
from pygments.lexers import DiffLexer
from processing import run as run_algorithm
from processing.algs.qgis.QgisAlgorithm import QgisAlgorithm
from processing.tools.postgis import uri_from_name as uri_from_db_conn_name
from qgis.core import (
    QgsDataSourceUri,
    QgsProcessing,
    QgsProcessingException,
    QgsProcessingParameterField,
    QgsProcessingParameterFileDestination,
    QgsProcessingParameterVectorLayer,
    QgsSettings,
)


# TODO: write tests
class FeatureDiffAlgorithm(QgisAlgorithm):
    """QGIS algorithm that takes two vector layers with identical columns
    and show differences between features of these two layers."""

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.
    ORIG_INPUT = 'ORIG_INPUT'
    NEW_INPUT = 'NEW_INPUT'
    FIELDS_TO_COMPARE = 'FIELDS_TO_COMPARE'
    OUTPUT_HTML_FILE = 'OUTPUT_HTML_FILE'

    def initAlgorithm(self, config):
        """Initialize algorithm with inputs and output parameters."""
        self.addParameter(QgsProcessingParameterVectorLayer(
            self.ORIG_INPUT,
            self.tr('Original layer'),
            types=[QgsProcessing.TypeVector],
        ))
        self.addParameter(QgsProcessingParameterVectorLayer(
            self.NEW_INPUT,
            self.tr('New layer'),
            types=[QgsProcessing.TypeVector],
        ))
        self.addParameter(QgsProcessingParameterField(
            self.FIELDS_TO_COMPARE,
            self.tr('Fields to compare'),
            None,
            self.ORIG_INPUT,
            allowMultiple=True,
        ))
        self.addParameter(QgsProcessingParameterFileDestination(
            self.OUTPUT_HTML_FILE,
            self.tr('HTML report'),
            self.tr('HTML files (*.html)'),
            None, True
        ))

    def name(self):
        """Algorithm identifier."""
        return 'featurediff'

    def displayName(self):
        """Algorithm human name."""
        return self.tr('Differences between features')

    def group(self):
        """Algorithm group human name."""
        return self.tr('Vector general')

    def groupId(self):
        """Algorithm group identifier."""
        return 'vectorgeneral'

    def processAlgorithm(self, parameters, context, feedback):
        """Actual processing steps."""
        orig_layer = self.parameterAsVectorLayer(parameters,
                                                 self.ORIG_INPUT,
                                                 context)
        new_layer = self.parameterAsVectorLayer(parameters,
                                                self.NEW_INPUT,
                                                context)
        # Check for SQLite or PostgreSQL or CSV type
        orig_layer_type = orig_layer.storageType()
        new_layer_type = new_layer.storageType()
        if not all(
                any(substr in type for substr in ('GPKG',
                                                  'SQLite',
                                                  'PostgreSQL'))
                for type in (orig_layer_type, new_layer_type)
        ):
            raise QgsProcessingException(self.tr(
                'Can only compare SQLite (GeoPackage, Spatialite) or '
                'PostgreSQL layers.'
            ))
        # Check that fields are the same
        fields_to_compare = self.parameterAsFields(parameters,
                                                   self.FIELDS_TO_COMPARE,
                                                   context)
        new_layer_fields = [field.name() for field in new_layer.fields()
                            if field.name() in fields_to_compare]
        if new_layer_fields != fields_to_compare:
            raise QgsProcessingException(self.tr(
                'Unable to compare layers with different fields or field order'
            ))
        with tempfile.NamedTemporaryFile('w', delete=False) as orig_csvf, \
                tempfile.NamedTemporaryFile('w', delete=False) as new_csvf:
            for layer, layer_type, csvf in (
                (orig_layer, orig_layer_type, orig_csvf),
                (new_layer, new_layer_type, new_csvf),
            ):
                if 'GPKG' in layer_type or 'SQLite' in layer_type:
                    qgis_conn, table = (layer.dataProvider().dataSourceUri()
                                        .split('|'))
                    _, table = table.split('=')
                    alg = 'exportsqlitequerytocsv'
                elif 'PostgreSQL' in layer_type:
                    uri = QgsDataSourceUri(
                        layer.dataProvider().dataSourceUri()
                    )
                    qgis_conn = _connection_name_from_info(
                        uri.connectionInfo()
                    )
                    if qgis_conn is None:
                        raise QgsProcessingException(self.tr(
                            'No database connection have been created for '
                            'PostgreSQL layer {0}.'.format(layer.name)
                        ))
                    table = '{schema}.{table}'.format(schema=uri.schema(),
                                                      table=uri.table())
                    alg = 'exportpostgresqlquerytocsv'
                select_sql = 'select {cols} from {table}'.format(
                    cols=', '.join(fields_to_compare), table=table
                )
                run_algorithm('csvtools:{alg}'.format(alg=alg), {
                    'DATABASE': qgis_conn,
                    'SELECT_SQL': select_sql,
                    'OUTPUT': csvf.name,
                })
        with open(orig_csvf.name) as orig_csvf, \
                open(new_csvf.name) as new_csvf:
            diff_output = difflib.unified_diff(
                orig_csvf.readlines(),
                new_csvf.readlines(),
                fromfile=orig_layer.name(),
                tofile=new_layer.name(),
            )
        results = dict()
        output_file = self.parameterAsFileOutput(parameters,
                                                 self.OUTPUT_HTML_FILE,
                                                 context)
        if output_file:
            with open(output_file, 'w') as f, io.StringIO() as diff_f:
                diff_f.writelines(diff_output)
                f.write(highlight(diff_f.getvalue(), DiffLexer(),
                                  HtmlFormatter(full=True)))
            results[self.OUTPUT_HTML_FILE] = output_file
        os.unlink(orig_csvf.name)
        os.unlink(new_csvf.name)
        return results


def _connection_name_from_info(conn_info):
    settings = QgsSettings()
    settings.beginGroup('/PostgreSQL/connections/')
    for group in settings.childGroups():
        if all(starmap(
                lambda x, y: x == y,
                zip(
                    filter(
                        lambda v: not v.startswith('sslrootcert'),
                        conn_info.split()
                    ),
                    filter(
                        lambda v: not v.startswith('sslrootcert'),
                        uri_from_db_conn_name(group).connectionInfo().split()
                    )
                )
        )):
            return group
    return None
